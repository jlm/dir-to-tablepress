require 'rubygems'
require 'date'
require 'json'
require 'nokogiri'
require 'open-uri'
require 'rest-client'

class TPTable
  attr_accessor :dir_url, :creds, :db_url, :db_creds

# @param [String] dir_url    URL of the directory to scan
# @param [Array<String>] creds  Username and password required to authenticate access to the directory
# @param [String] db_url     URL of the database in which to look up the file's description
# @param [Array] db_creds    Username and password required to authenticate access to the database
  def initialize(dir_url, creds: [], db_url: '', db_creds: [])
    @dir_url = dir_url
    @creds = creds
    @db_url = db_url
    @db_creds = db_creds
    @files = []
  end

  ####
  # Look up a filename in the web-based filename database and return its description
  ####
  # @param [String] filename
  def query_db(filename)
    uri = URI.parse(@db_url)
    uri = URI::HTTP.build(host: uri.host, path: uri.path, query: "filename=#{filename}")
    page = open(uri, http_basic_authentication: @db_creds) { |f| f.read }
    pagedoc = Nokogiri::XML(page)
    pagedoc.css('description').text
  end

  ####
  # Retrieve a directory listing from a web server and parse it to extract filenames and dates.  Optionally query a
  # web-based database to retrieve a textual description of the file.
  ####
  # @param [String] prefix     A prefix to prepend to the filename in recursive invocations
  # @param [Bool] lookup       Should the filename be looked up in the web database?
  def parse_dir(prefix: '', lookup: false)
    page = open(@dir_url, http_basic_authentication: @creds) { |f| f.read }
    pagedoc = Nokogiri::HTML(page)
    found_parent = false
    pagedoc.at('pre').children.each do |el|
      unless found_parent
        found_parent = /Parent Directory/.match(el.text) unless found_parent
        next unless found_parent
      end
      next unless found_parent
      next if /Parent Directory/.match(el.text)
      puts el.text if $DEBUG
      if el.name == 'a'
        if /\/$/.match(el.text)
          puts "Directory #{el['href']}" if $DEBUG
          # XXX What's the best way to deal with recursive calls in a class?  Could use recursive instansiation or
          # make parse_dir a Class method instead of an Instance method.
          dir = TPTable.new(@dir_url + el['href'], creds: @creds, db_url: @db_url, db_creds: @db_creds)
          @files += dir.parse_dir(prefix: el.text, lookup: lookup)
        else
          puts "It's a file #{el['href']} with prefix #{prefix}" if $DEBUG
          name = el.text
          file = { name: prefix + name,
                   href: @dir_url + el['href'],
                   date: DateTime.parse(el.next) }
          file[:desc] = query_db(name) if lookup
          @files << file
        end
      end
    end
    return @files
  end

  ####
  # Convert the file list to a TablePress specification in JSON.  Optionally query a
  # web-based database to retrieve a textual description of the file.
  ####
  # @param [Integer] per_page  Tell TablePress how many entries to show per page
  # @param [Bool] lookup       Should the filename be looked up in the web database?
  def to_json(per_page: 10, lookup: false)
    # Build a TablePress table specification which will be output as a JSON object for import into Wordpress.
    table = {
        name: 'Archive',
        description: "Archive of files for #{File.split(@dir_url)[-1]}, generated by dir-to-tablepress.rb at #{Time.now}",
        options: {
            table_head: true,
            table_foot: false,
            alternating_row_colors: true,
            row_hover: true,
            print_name: true,
            print_name_position: 'above',
            print_description: false,
            print_description_position: 'below',
            extra_css_classes: '',
            use_datatables: true,
            datatables_sort: true,
            datatables_filter: true,
            datatables_paginate: true,
            datatables_lengthchange: true,
            datatables_paginate_entries: per_page,
            datatables_info: true,
            datatables_scrollx: false,
            datatables_custom_commands: '"order": [[ 0, \'desc\' ]], "columnDefs": [ { "type": "date", "targets": [ 0 ] } ]'
        }
    }

    # Add table headers
    table[:data] = lookup ? [ %w[Date Document Description] ] : [ %w[Date Document] ]

    @files.each do |f|
      builder = Nokogiri::XML::Builder.new do |xml|
        xml.a(File.split(f[:name])[-1], href: f[:href])
      end
      link = builder.to_xml(save_with: Nokogiri::XML::Node::SaveOptions::NO_DECLARATION)
      entry = [f[:date].to_date.to_s, link]
      entry << f[:desc] if lookup
      table[:data] << entry
    end
    JSON.pretty_generate(table)
  end

end
